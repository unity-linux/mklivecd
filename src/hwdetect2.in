#!/usr/bin/perl
#
# LiveCD hardware detection script
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# Adapted for Mandriva service_harddrake script
# The latest version of this script can be found at http://svn.unity-linux.org/

use lib qw(/usr/lib/libDrakX);

BEGIN { $ENV{DISABLE_DRAKBUG} = 1 }

use standalone;     #- warning, standalone must be loaded very first, for 'explanations'
use c;
use common;
use interactive;
use detect_devices;
use Getopt::Long;
use harddrake::data;
use harddrake::autoconf;
use harddrake::sound;
use modules;
use Storable qw(store retrieve);
use lang;

### global constants
my $SCRIPT_NAME    = "hwdetect";
my $SCRIPT_VER     = "@MKLIVECDVER@";
my $DEF_KEYBOARD   = "@DEF_KEYBOARD@";

my $prefix        = "";
my $cmdline;

sub get_locales_from_isolinux() {
	my ($lang) = cat_("/proc/cmdline") =~ /\blang=(.+?)\b/;
	my $h = lang::lang_to_ourlocale($lang);
	if($lang && member($h->{lang},lang::list_langs(exclude_non_installed => 1))) {
		lang::set($h);
	}
	lang::write_and_install($h);
}

sub hwdetect_getxfree() {
my $XORGFILE=('
# File generated by XFdrake (rev 57713)

# **********************************************************************
# Refer to the xorg.conf man page for details about the format of
# this file.
# **********************************************************************

Section "Files"
    # font server independent of the X server to render fonts.
    FontPath "unix/:-1"
    
    # minimal fonts to allow X to run without xfs
    FontPath "/usr/share/fonts/misc:unscaled"
EndSection

Section "Extensions"
    Option "Composite"
EndSection

Section "ServerFlags"
    #DontZap # disable <Crtl><Alt><BS> (server abort)
    AllowMouseOpenFail # allows the server to start up even if the mouse does not work
    #DontZoom # disable <Crtl><Alt><KP_+>/<KP_-> (resolution switching)
EndSection

Section "Module"
    Load "dbe" # Double-Buffering Extension
    Load "v4l" # Video for Linux
    Load "extmod"
    Load "type1"
    Load "freetype"
EndSection

Section "InputDevice"
    Identifier "Keyboard1"
    Driver "kbd"
    Option "XkbModel" "pc105"
    Option "XkbLayout" "us"
    Option "XkbOptions" "compose:rwin"
EndSection

Section "InputDevice"
    Identifier "Mouse1"
    Driver "mouse"
    Option "Protocol" "ExplorerPS/2"
    Option "Device" "/dev/mouse"
EndSection

Section "InputDevice"
    Identifier "Mouse2"
    Driver "evdev"
    Option "product" "0x0006"
    Option "HWheelRelativeAxisButtons" "7 6"
    Option "vendor" "0x0002"
EndSection

Section "Monitor"
    Identifier "monitor1"
    VendorName "Generic"
    ModelName "1024x768 @ 60 Hz"
    HorizSync 31.5-48.5
    VertRefresh 50-70
    
    # Monitor preferred modeline (60.0 Hz vsync, 64.0 kHz hsync, ratio 5/4)
    ModeLine "1280x1024" 108 1280 1328 1440 1688 1024 1025 1028 1066 +hsync +vsync
    
    # TV fullscreen mode or DVD fullscreen output.
    # 768x576 @ 79 Hz, 50 kHz hsync
    ModeLine "768x576"     50.00  768  832  846 1000   576  590  595  630
    
    # 768x576 @ 100 Hz, 61.6 kHz hsync
    ModeLine "768x576"     63.07  768  800  960 1024   576  578  590  616
EndSection

Section "Device"
    Identifier "device1"
    Driver "fbdev"
    Option "DPMS"
EndSection

Section "Screen"
    Identifier "screen1"
    Device "device1"
    Monitor "monitor1"
    DefaultColorDepth 16
    
    Subsection "Display"
        Depth 8
        Modes "1024x768" "800x600" "640x480"
    EndSubsection
    
    Subsection "Display"
        Depth 15
        Modes "1024x768" "800x600" "640x480"
    EndSubsection
    
    Subsection "Display"
        Depth 16
        Modes "1024x768" "800x600" "640x480"
    EndSubsection
    
    Subsection "Display"
        Depth 24
        Modes "1024x768" "800x600" "640x480"
    EndSubsection
EndSection

Section "ServerLayout"
    Identifier "layout1"
    InputDevice "Keyboard1" "CoreKeyboard"
    InputDevice "Mouse1" "CorePointer"
    InputDevice "Mouse2" "SendCoreEvents"
    Screen "screen1"
EndSection

');

my $FBDEV;
	open $FBDEV, '>', "$prefix/etc/X11/xorg.conf";
	print $FBDEV $XORGFILE;
		close $FBDEV;
}

sub hwdetect_getxfree1() {
my $XORGFILE=('
# File generated by XFdrake (rev 57713)

# **********************************************************************
# Refer to the xorg.conf man page for details about the format of
# this file.
# **********************************************************************

Section "Files"
    # font server independent of the X server to render fonts.
    FontPath "unix/:-1"
    
    # minimal fonts to allow X to run without xfs
    FontPath "/usr/share/fonts/misc:unscaled"
EndSection

Section "Extensions"
    Option "Composite"
EndSection

Section "ServerFlags"
    #DontZap # disable <Crtl><Alt><BS> (server abort)
    AllowMouseOpenFail # allows the server to start up even if the mouse does not work
    #DontZoom # disable <Crtl><Alt><KP_+>/<KP_-> (resolution switching)
EndSection

Section "Module"
    Load "dbe" # Double-Buffering Extension
    Load "v4l" # Video for Linux
    Load "extmod"
    Load "type1"
    Load "freetype"
EndSection

Section "InputDevice"
    Identifier "Keyboard1"
    Driver "kbd"
    Option "XkbModel" "pc105"
    Option "XkbLayout" "us"
    Option "XkbOptions" "compose:rwin"
EndSection

Section "InputDevice"
    Identifier "Mouse1"
    Driver "mouse"
    Option "Protocol" "ExplorerPS/2"
    Option "Device" "/dev/mouse"
EndSection

Section "InputDevice"
    Identifier "Mouse2"
    Driver "evdev"
    Option "product" "0x0006"
    Option "HWheelRelativeAxisButtons" "7 6"
    Option "vendor" "0x0002"
EndSection

Section "Monitor"
    Identifier "monitor1"
    VendorName "Generic"
    ModelName "1024x768 @ 60 Hz"
    HorizSync 31.5-48.5
    VertRefresh 50-70
    
    # Monitor preferred modeline (60.0 Hz vsync, 64.0 kHz hsync, ratio 5/4)
    ModeLine "1280x1024" 108 1280 1328 1440 1688 1024 1025 1028 1066 +hsync +vsync
    
    # TV fullscreen mode or DVD fullscreen output.
    # 768x576 @ 79 Hz, 50 kHz hsync
    ModeLine "768x576"     50.00  768  832  846 1000   576  590  595  630
    
    # 768x576 @ 100 Hz, 61.6 kHz hsync
    ModeLine "768x576"     63.07  768  800  960 1024   576  578  590  616
EndSection

Section "Device"
    Identifier "device1"
    Driver "vesa"
    Option "DPMS"
EndSection

Section "Screen"
    Identifier "screen1"
    Device "device1"
    Monitor "monitor1"
    DefaultColorDepth 16
    
    Subsection "Display"
        Depth 8
        Modes "1024x768" "800x600" "640x480"
    EndSubsection
    
    Subsection "Display"
        Depth 15
        Modes "1024x768" "800x600" "640x480"
    EndSubsection
    
    Subsection "Display"
        Depth 16
        Modes "1024x768" "800x600" "640x480"
    EndSubsection
    
    Subsection "Display"
        Depth 24
        Modes "1024x768" "800x600" "640x480"
    EndSubsection
EndSection

Section "ServerLayout"
    Identifier "layout1"
    InputDevice "Keyboard1" "CoreKeyboard"
    InputDevice "Mouse1" "CorePointer"
    InputDevice "Mouse2" "SendCoreEvents"
    Screen "screen1"
EndSection

');

my $FBDEV;
	open $FBDEV, '>', "$prefix/etc/X11/xorg.conf";
	print $FBDEV $XORGFILE;
		close $FBDEV;
}

sub hwdetect_init() {
	select(STDOUT);
	$| = 1;
	open STDERR, '>', "/dev/null";

	# initialise our /proc/cmdline
	%cmdline = map {
		chomp;
		my ($name, $value) = split(/=/);
		$name => $value || 1;
	} split(/ /, cat_('/proc/cmdline'));
	# start now
}

sub pre_config_video() {
# If user selects safevideomode from grub
if (defined($cmdline{framebuffer})) {
              hwdetect_getxfree();
        }
elsif (defined($cmdline{vesa})) {
              hwdetect_getxfree1();
	 }
}

hwdetect_init();
# We need to pre-install the xorg file before the check by service_harddrake
pre_config_video();

# Change locales based on isolinux language selection
get_locales_from_isolinux();

# Now we switch to service_hardrake script + VESA modes
# No need to remove too much so that we can take advantage of updates from mdv

my $force = 1;

my $invert_do_it = $ARGV[0] eq 'X11' ? 1 : 0;
my ($hw_sysconfdir, $timeout) = ("/etc/sysconfig/harddrake2", $invert_do_it ? 600 : 25);
my $last_boot_config = "$hw_sysconfdir/previous_hw";

$last_boot_config .= '_X11' if $invert_do_it;

# first run ? if not read old hw config
my $previous_config;
if (-f $last_boot_config && -s $last_boot_config) {
    eval { $previous_config = Storable::retrieve($last_boot_config) };
    log::explanations("resetting previous hardware file ($@)") if $@;
}
$previous_config ||= {};
$previous_config = $$previous_config if ref($previous_config) !~ /HASH/;
my $first_run = is_empty_hash_ref($previous_config);

my $modules_conf = modules::any_conf->read;

my $isLaptop = detect_devices::isLaptop();
my $curr_kernel = c::kernel_version();
my ($kernel_major) = $curr_kernel =~ /^(\d+\.\d+)/;

my %previous_kernel_config = getVarsFromSh("$hw_sysconfdir/kernel");
setVarsInSh("$hw_sysconfdir/kernel", { KERNEL => $kernel_major, IS_LAPTOP => bool2text($isLaptop) });
my %cfg = getVarsFromSh("$hw_sysconfdir/service.conf");

# autoreconfigure laptop-dependent services when switching from laptop to desktop, and vice versa
if (!exists $previous_kernel_config{IS_LAPTOP} || $force || $isLaptop != text2bool($previous_kernel_config{IS_LAPTOP})) {
    log::explanations("Autoconfiguring laptop tools since we switched between laptop and desktop systems");
    harddrake::autoconf::laptop($isLaptop);
}

my $known_kernels = "$hw_sysconfdir/kernels";
if (!member($curr_kernel, chomp_(cat_($known_kernels)))) {
    harddrake::autoconf::fix_aliases($modules_conf) if !$first_run;
    append_to_file($known_kernels, "$curr_kernel\n");
}

my @cards = (
    {
        ldetect_driver_regexp => 'Card:NVIDIA',
        xorg_driver_regexp => 'nv.+',
        module_names => [ qw(NVdriver nvidia.o nvidia.ko nvidia71xx.ko nvidia96xx.ko nvidia97xx.ko nvidia173.ko nvidia-current.ko) ]
    },
    {
        ldetect_driver_regexp => 'Card:ATI Radeon',
        xorg_driver_regexp => 'fglrx',
        module_names => [ qw(fglrx.ko fglrx-hd2000.ko) ]
    }
);

foreach my $card (@cards) {
    next if !find { $_->{driver} =~ /$card->{ldetect_driver_regexp}/ } detect_devices::probeall();
    if (find { -e join('', "/lib/modules/", c::kernel_version(), $_) }
          map { ("/dkms/$_", "/dkms-binary/$_", "/kernel/$_") } map { "/drivers/$_" } map { ("extra/$_", "video/$_", "char/$_", "char/drm/$_") } map { $_, "$_.gz" } @{$card->{module_names}}) {

        # do not automatically switch from nv to nvidia (in order to handle
        # cases where nvidia module crashes the system):
        #
        # substInFile {
        #    log::explanations("switch XFree86 driver from nv to nvidia") if /Driver "nv"/;
        #    s!Driver "nv.*"!Driver "nvidia"!g;
        #    s!#*( Load.*glx)!\1!g;
        # } $_ foreach "/etc/X11/XF86Config-4", "/etc/X11/XF86Config";
    } else {
        require Xconfig::card;
        my @cards = Xconfig::card::probe();
        my $driver = $cards[0]{Driver};
        my $new_driver = $1 if cat_('/etc/X11/xorg.conf') =~ /Driver "($card->{xorg_driver_regexp})"/;
        if ($new_driver) {
            cp_af('/etc/X11/xorg.conf', "/etc/X11/xorg.conf.mdv$^T");
            substInFile { s!Driver "($card->{xorg_driver_regexp})"!Driver "$driver"!g } '/etc/X11/xorg.conf';
            touch('/var/run/harddrake_swithed_to_free_driver');
            log::explanations("switch X.org driver from $new_driver to $driver");
            touch('/var/run/harddrake-notify-x11-free-driver-switch');
            Xconfig::card::libgl_config_and_more({ Driver => $driver });
        }
    }
}

my $is_globetrotter = -f '/usr/sbin/mdkmove';

my (%config, $wait);
my $in;
my $splash = -f '/proc/splash';
my $splash_was_silent = cat_('/proc/splash') =~ /, silent : on/;

# For each hw, class, detect device, compare and offer to reconfigure if needed
foreach my $hw_class (@harddrake::data::tree) {
    my ($Ident, $item, $configurator, $detector, $do_it) = @$hw_class{qw(class string configurator detector checked_on_boot)};
    next if member($cfg{"DETECT_$Ident"}, qw(NO no));

    $configurator ||= $hw_class->{configurator};

    next unless $do_it ^ $invert_do_it;
    # No detector ? (should never happen but who know ?)
    ref($detector) eq 'CODE' or next;

    my %ID = map {
        my $i = $_;
        my $id = defined $i->{device} ? $i->{device} : join(':', map { $i->{$_} } qw(vendor id subvendor subid));
        $id => $i;
    } eval { $detector->({}) };
    $config{$Ident} = \%ID;
    next if !$is_globetrotter && !$force && $first_run; # do not fsck on first run but if --force

    my $oldconfig = $force ? {} : $previous_config->{$Ident};

    my $msg;
    my @was_removed = difference2([ keys %$oldconfig ], [ keys %ID ]);
    if (@was_removed) {
     $msg .= N("Some devices in the \"%s\" hardware class were removed:\n", $item) .
       join('', map { N("- %s was removed\n", harddrake::data::custom_id($oldconfig->{$_}, $item)) } @was_removed) . "\n";
    }
    my @added = difference2([ keys %ID ], [ keys %$oldconfig ]);
    $msg .= N("Some devices were added: %s\n", $item) if @added;
    $msg .= N("- %s was added\n", harddrake::data::custom_id($ID{$_}, $item)) foreach @added;
    log::explanations("removed $Ident: " . harddrake::data::custom_id($oldconfig->{$_}, $item)) foreach @was_removed;
    log::explanations("added $Ident: " . harddrake::data::custom_id($ID{$_}, $item)) foreach @added;

    if ($Ident eq 'FIREWIRE_CONTROLLER' && any { $_->{driver} eq 'ohci1394' } @ID{@added}) {
        modules::load_and_configure($modules_conf, 'ohci1394');
        $modules_conf->write;
    }

    @added || @was_removed or $cfg{"DETECT_$Ident"} ne 'force' and next;

    next if $Ident eq 'MOUSE' && $kernel_major ne $previous_kernel_config{KERNEL} && $cfg{"DETECT_$Ident"} ne 'force';

    my @configurator_pool = $configurator;

    if ($Ident eq "AUDIO") {
        # automatic sound slots configuration
        rm_rf("/etc/asound.state") if -e "/etc/asound.state";
        harddrake::sound::configure_sound_slots($modules_conf);
        next;
    } elsif ($Ident eq "ETHERNET") {
        $modules_conf->remove_alias_regexp('^(wlan|eth)[0-9]*$');
        modules::load_category($modules_conf, 'network/main|gigabit|usb|wireless|firewire|pcmcia');
        require network::connection::ethernet;
        network::connection::ethernet::configure_eth_aliases($modules_conf);
        require network::rfswitch;
        network::rfswitch::configure();
        require network::shorewall;
        network::shorewall::update_interfaces_list();
        $modules_conf->write;
        next;
    } elsif (member($Ident, qw(ATA_STORAGE CARD_READER RAID_STORAGE SATA_STORAGE SCSI_CONTROLLER))) {
        # set scsi_hostadapter in modprobe.conf:
        modules::load_category($modules_conf, 'disk/' . {
			ATA_STORAGE => 'ide',
			SATA_STORAGE => 'sata',
			SCSI_CONTROLLER => 'scsi',
			RAID_STORAGE => 'hardware_raid',
			CARD_READER => 'card_reader'
		}->{$Ident});
        $modules_conf->write;
        next;
    } elsif (member($Ident, qw(AGP DVB TV))) {
        my @old_drivers = uniq(map { $_->{driver} } values %$oldconfig);
        my @new_drivers = uniq(map { $_->{driver} } values %ID);
        # load DVB & TV drivers (eg: for One), not for AGP (done by X):
        modules::load_category($modules_conf, 'multimedia/' . lc($Ident)) if member($Ident, qw(DVB TV));
        $modules_conf->remove_module(difference2(\@old_drivers, \@new_drivers));
        # add agpgart and the like modules to modprobe.preload if needed:
        $modules_conf->write;
        foreach (difference2(\@new_drivers, \@old_drivers)) {
            eval { modules::load($_) };
            warn "warning: $@" if $@;
        }
        next;
    } elsif ($Ident eq "BLUETOOTH") {
        harddrake::autoconf::bluetooth(scalar keys %ID);
    } elsif ($Ident eq "PCMCIA_CONTROLLER") {
        harddrake::autoconf::pcmcia(keys %ID ? first(values(%ID))->{driver} : '');
    } elsif ($Ident eq "USB_CONTROLLER") {
        # nearly useless (only mkinitrd uses it):
        modules::load_category($modules_conf, 'bus/usb');
        $modules_conf->write;
    } elsif ($Ident eq "VIDEO") {
        # explicitely NOT read the existing config (eg: new profile with globetrotter)
	if (defined($cmdline{framebuffer})) {
              hwdetect_getxfree();
        }
	elsif (defined($cmdline{vesa})) {
              hwdetect_getxfree1();
	 }
	else {
                harddrake::autoconf::xconf($modules_conf, {});
		$modules_conf->write;
	} 
        next;
    } elsif ($Ident eq "MOUSE") {
        harddrake::autoconf::mouse_conf($modules_conf);
        next;
    } elsif ($Ident eq "CPU") {
        harddrake::autoconf::cpufreq();
    } elsif ($Ident eq "FLOPPY") {
        harddrake::autoconf::floppy();
    }

    next if $is_globetrotter && !$hw_class->{automatic};
    next unless $configurator_pool[0];
    if (ref($configurator) ne 'CODE' && !-x first(split /\s+/, $configurator_pool[0])) {
        log::explanations(qw(skip $Ident configuration since "$configurator" is not executable));
        next;
    }
    my ($pid, $no, $res);
    $hw_class->{automatic} ||= ref($configurator) eq 'CODE';

    if (!$hw_class->{automatic}) {
        $SIG{ALRM} = sub { $no = 1; kill 15, $pid };
        unless ($pid = fork()) {
            $splash and eval { output('/proc/splash', 'verbose') } and $splash = 0;
            exec("/usr/share/harddrake/confirm", $Ident, $timeout, $msg);
        }
        alarm($timeout);
        wait();
        $res = $?;
        alarm(0);
    } else {
        $res = 1;
    }
    if (ref($configurator) eq 'CODE') {
        eval { $configurator->() };
        log::explanations(qw(cannot run "$configurator": $@)) if $@;
    } elsif (!$no && $res) {
        foreach my $program (@configurator_pool) {
            if (fork()) {
                wait();
            } else {
                log::explanations(qq(run "$program"));
                exec("$program 2>/dev/null") or do {
                    log::explanations(qq(cannot run "$program"));
                    require POSIX;
                    POSIX::_exit();
                };
            }
        }
    }
    if (!$hw_class->{automatic}) {
        require interactive;
        undef $wait;
        $in ||= interactive->vnew;
        $wait = $in->wait_message(N("Please wait"), N("Hardware probing in progress"));
    }

}

# output new hw config
log::explanations("created file $last_boot_config");
Storable::store(\%config, $last_boot_config);

# restore bootsplash mode
$splash_was_silent and eval { output('/proc/splash', 'silent') };


$in->exit(0) if $in;
